#version 460 core

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
layout(rgba16f, binding = 0) uniform image2D img_output; // Use rgba16f to match the "f2" dtype in TextureDesc

uniform mat4 u_inv_view_proj;
uniform vec3 u_camera_pos;
uniform int u_max_bounces;
uniform int u_samples_per_pixel;
uniform int u_frame_index;
uniform bool u_denoiser_enabled;

struct Ray {
    vec3 origin;
    vec3 dir;
};


struct Triangle {
    vec4 v0; // xyz: pos, w: metalness
    vec4 v1; // xyz: pos, w: roughness
    vec4 v2; // xyz: pos, w: padding/unused
    vec4 albedo; // rgb: color, w: unused
};
layout(std430, binding = 1) readonly buffer TriangleBuffer {
    Triangle triangles[];
};
uniform int u_triangle_count;


struct PointLight {
    vec4 position;
    vec4 color;
};
layout(std430, binding = 2) readonly buffer LightBuffer {
    PointLight lights[];
};
uniform int u_light_count; // Max of 8

uniform vec3 u_sun_direction;
uniform vec3 u_sun_color;
layout(binding=5) uniform sampler2D u_sky_lut;

#define PI 3.14159265359


uint pcg_hash(uint v) {
    uint state = v * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

float rand(inout uint seed) {
    seed = pcg_hash(seed);
    return float(seed) * (1.0 / 4294967296.0);
}

// Return a random direction in a hemisphere oriented around normal N
vec3 random_cosine_weighted_hemisphere(vec3 N, inout uint seed) {
    float r1 = rand(seed);
    float r2 = rand(seed);
    float phi = 2.0 * 3.14159265 * r1;
    float x = cos(phi) * sqrt(r2);
    float y = sin(phi) * sqrt(r2);
    float z = sqrt(1.0 - r2);
    
    // Build Orthonormal Basis
    vec3 helper = abs(N.x) > 0.99 ? vec3(0, 1, 0) : vec3(1, 0, 0);
    vec3 tangent = normalize(cross(helper, N));
    vec3 bitangent = cross(N, tangent);
    
    return tangent * x + bitangent * y + N * z;
}

vec2 dir_to_uv(vec3 dir) {
    // atan(z, x) gives longitude (-PI to PI)
    // asin(y) gives latitude (-PI/2 to PI/2)
    float y = clamp(dir.y, -1.0, 1.0);
    float u = 0.5 + atan(dir.x, dir.z) / (2.0 * PI);
    float v = 0.5 + asin(y) / PI;
    return vec2(u, v);
}

bool hit_triangle(Ray r, Triangle tri, out float t, out vec3 normal) {
    vec3 v0 = tri.v0.xyz;
    vec3 v1 = tri.v1.xyz;
    vec3 v2 = tri.v2.xyz;

    vec3 edge1 = v1 - v0;
    vec3 edge2 = v2 - v0;
    vec3 h = cross(r.dir, edge2);
    float a = dot(edge1, h);

    if (a > -0.00001 && a < 0.00001) return false; // Ray is parallel to triangle

    float f = 1.0 / a;
    vec3 s = r.origin - v0;
    float u = f * dot(s, h);

    if (u < 0.0 || u > 1.0) return false;

    vec3 q = cross(s, edge1);
    float v = f * dot(r.dir, q);

    if (v < 0.0 || u + v > 1.0) return false;

    t = f * dot(edge2, q);
    if (t > 0.00001) {
        normal = normalize(cross(edge1, edge2));
        return true;
    }
    return false;
}

void main() {
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 dims = imageSize(img_output);

    if (pixel_coords.x >= dims.x || pixel_coords.y >= dims.y) return;

    uint seed = uint(pixel_coords.y * 1920 + pixel_coords.x) ^ pcg_hash(uint(u_frame_index));

    vec3 pixel_color_accumulator = vec3(0.0);

    for (int s = 0; s < u_samples_per_pixel; s++) {
        vec2 jitter = vec2(rand(seed), rand(seed)) - 0.5;
        vec2 uv = (vec2(pixel_coords) + 0.5 + jitter) / vec2(dims);

        // Ray gen
        vec2 ndc = uv * 2.0 - 1.0;
        vec4 target = u_inv_view_proj * vec4(ndc, -1.0, 1.0);
        vec3 world_target = target.xyz / target.w;

        Ray current_ray;
        current_ray.origin = u_camera_pos;
        current_ray.dir = normalize(world_target - current_ray.origin);

        vec3 throughput = vec3(1.0);
        vec3 total_radiance = vec3(0.0);

        for (int bounce = 0; bounce < u_max_bounces; bounce++) {
            float closest_t = 1e30;
            int hit_idx = -1;
            vec3 hit_normal;
            bool hit_found = false;

            for (int i = 0; i < u_triangle_count; i++) {
                float t; vec3 tri_normal;
                if (hit_triangle(current_ray, triangles[i], t, tri_normal)) {
                    if (t > 0.001 && t < closest_t) {
                        closest_t = t;
                        hit_idx = i;
                        hit_normal = tri_normal;
                        hit_found = true;
                    }
                }
            }

            if (hit_found) {
                Triangle tri = triangles[hit_idx];
                vec3 hit_pos = current_ray.origin + closest_t * current_ray.dir;

                vec3 material_color = tri.albedo.rgb;
                float metalness = tri.v0.w;
                float roughness = tri.v1.w;

                vec3 lighting_contribution = vec3(0.0);
                vec3 to_sun_dir = -normalize(u_sun_direction);

                Ray sun_shadow_ray;
                sun_shadow_ray.origin = hit_pos + hit_normal * 0.001;
                sun_shadow_ray.dir = to_sun_dir; 
                bool sun_in_shadow = false;

                for (int i = 0; i < u_triangle_count; i++) {
                    float st;
                    vec3 sn;
                    if (hit_triangle(sun_shadow_ray, triangles[i], st, sn)) {
                        if (st > 0.0) {
                            sun_in_shadow = true;
                            break;
                        }
                    }
                }

                if (!sun_in_shadow) {
                    float sun_diff = max(dot(hit_normal, to_sun_dir), 0.0);

                    lighting_contribution += material_color * u_sun_color * sun_diff;
                }

                for (int l = 0; l < u_light_count; l++) {
                    vec3 light_dir = lights[l].position.xyz - hit_pos;
                    float light_dist = length(light_dir);
                    light_dir = normalize(light_dir);

                    // Shadow Ray
                    Ray shadow_ray;
                    shadow_ray.origin = hit_pos + hit_normal * 0.001;
                    shadow_ray.dir = light_dir;
                    bool in_shadow = false;

                    for (int i = 0; i < u_triangle_count; i++) {
                        float st; vec3 sn;
                        if (hit_triangle(shadow_ray, triangles[i], st, sn)) {
                            if (st < light_dist) {
                                in_shadow = true;
                                break;
                            }
                        }
                    }

                    if (!in_shadow) {
                        float diff = max(dot(hit_normal, light_dir), 0.0);
                        float attenuation = 1.0 / (light_dist * light_dist);
                        lighting_contribution += material_color * lights[l].color.rgb * lights[l].color.w * diff * attenuation;
                    }
                }

                total_radiance += throughput * lighting_contribution;

                current_ray.origin = hit_pos + hit_normal * 0.001;
                vec3 reflect_dir = reflect(current_ray.dir, hit_normal);
                vec3 diffuse_dir = random_cosine_weighted_hemisphere(hit_normal, seed);

                reflect_dir = normalize(mix(reflect_dir, diffuse_dir, roughness * roughness));

                if (rand(seed) < metalness) {
                    current_ray.dir = reflect_dir;
                } else {
                    current_ray.dir = diffuse_dir;
                }

                throughput *= material_color;

            } else {
                vec2 uv = dir_to_uv(normalize(current_ray.dir));
                vec3 sky_color = textureLod(u_sky_lut, uv, 0.0).rgb;
                total_radiance += throughput * sky_color; 
                break;
            }
        }

        pixel_color_accumulator += total_radiance;
    }

    vec3 average_radiance = pixel_color_accumulator / float(u_samples_per_pixel);
   
    if (u_denoiser_enabled) {
        vec3 old_color = imageLoad(img_output, pixel_coords).rgb;
        float weight = 1.0 / float(u_frame_index + 1);
        vec3 final_accumulated = mix(old_color, average_radiance, weight);
        imageStore(img_output, pixel_coords, vec4(final_accumulated, 1.0));
    } else {
        imageStore(img_output, pixel_coords, vec4(average_radiance, 1.0));
    }
}